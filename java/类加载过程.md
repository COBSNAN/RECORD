---
title: 类加载过程
tags: java
grammar_cjkRuby: true
---

### 类加载的生命周期
加载、验证、准备、解析、初始化、使用和卸载7个阶段

### 类初始化条件
1.使用new类实例化对象、读取类的静态方法或字段（final修饰的静态字段除外）
2.使用java.lang.reflect包的方法对类进行反射调用
3.初始化子类，其父类没有初始化，则先初始化父类
4.虚拟机启动时，用户指定一个执行的主类，虚拟机会先初始化这个主类
5.使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发器初始化

*接口与类有所区别是第三条，接口只有真正使用到父接口的时候才会初始化 *
### 加载
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转换为方法去的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

### 验证
- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

### 准备
> 正式为类变量分配内存并设置类变量初始值的阶段

*内存分配仅包括类变量，不包括实例变量
  初始值为零值，final修饰的除外*
  
  ### 解析
  - 类或接口的解析
  - 字段解析
  - 类方法解析
  - 接口方法解析

### 初始化
> 初始化阶段是执行泪构造器<clinit>()方法的过程

- <clinit>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。静态语句块中只能访问其之前的变量，但对于其之后的变量，可以赋值，不能访问。
- <clinit>()方法与类的构造函数不同，其不用显示的调用父类构造器，虚拟机保证子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。
- 虚拟机会对<clinit>()方法在多线程环境中正确地加锁、同步。只会进入<clinit>()方法一次。

### 双亲委派模型
- 启动类加载器：负责加载<JAVA_HOME>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的类库才加载。
- 扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中,或者被java.ext.dirs系统变量所指定的路径中的所有类库
- 应用程序类加载器：加载用户类路径上所指定的类库。

**加载器之间的父子关系一般不会已继承的关系来实现的，而是都使用组合关系来复用父加载器的代码**