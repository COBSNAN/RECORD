---
title: 线程
tags: java,线程
grammar_cjkRuby: true
---

### 创建线程的两种方法

继承Thread类或实现Runnable接口。都是重写了 run() 方法。
执行线程都是用Thread类的start()方法。

> 线程的5种状态
- 新建状态（New）:线程对象被创建后，就进入了新建状态。eg，Thread = new Thread();
- 就绪状态（Runnable）:又称可执行状态。线程对象创建后调用了start() 方法启动线程
- 运行状态（Running）:线程获取CPU进行执行。只能从就绪状态进入运行状态。
- 阻塞状态（Blocked）:因某种原因放弃CPU使用权，暂时停止运行。原因有三种：
	- 等待阻塞 --> 通过调用线程的wait()或sleep()或join()方法，让线程等待某工作完成。
	- 同步阻塞 --> 线程在获取**synchronized**同步锁失败（被其他线程占用）
	- 其他阻塞 --> 通过调用线程的发出了**I/O**请求时，线程会进入同步阻塞状态
- 死亡状态（Dead）:线程执行完了或异常退出了run()方法。结束生命周期

![流程图][1]

**注意** 
这五种状态是我们认知上的五种状态，当然在程序执行中，阻塞状态就有多种类型，
下面是java源代码中的六种状态
1. NEW 在执行start()方法之前
2. RUNNABLE 执行或等待资源 
3. BLOCKED 线程在等待monitor锁（synchronized 关键字）
4. WAITING Object.wait() 和 Thread.join() 和 LockSupport.park() 方法会造成这种等待阻塞
5. TIMED_WAITING 暂且叫限时等待，是上面方法加了一个等待时间，或者LockSupport的其他方法
6. TERMINATED 终止状态·

线程可以设置为守护线程，但必须在调用 start()之前设置。
### 线程池的使用
> 构造方法
```
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```
- corePoolSize:线程池维护线程的最少数量
- maximumPoolSize:线程池维护线程的最大数量
- keepAliveTime:线程池维护线程所允许的空闲时间
- unit:线程池维护线程所信息的空闲时间的单位
- workQueue:线程池所使用的缓冲队列
- threadFactory:线程创建工厂类
- handler:线程池对任务的处理策略

> BlockingQueue常用的3个实现类

1. ArrayBlockingQueue 构造参数**必须**带一个int参数来指明其大小，FIFO
2. LinkedBlockingQuene 大小不定，可以人为指定，若没有有Integer.MAX_VALUE来决定。FIFO
3. SynchronousQueue 对其操作必须放和取交替完成。

>> LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.
	 






  [1]: https://www.github.com/COBSNAN/ImageHub/raw/master/1489924381702.jpg "1489924381702"