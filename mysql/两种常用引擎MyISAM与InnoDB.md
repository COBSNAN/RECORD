---
title: 两种常用引擎MyISAM与InnoDB
tags: mysql
grammar_cjkRuby: true
---

### MyISAM
> 不支持事务，也不支持外键，访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。

**MyISAM表是独立于操作系统,可以轻松地将其从Windows服务器移植到Linux服务器.建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件**

例如,建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：

1. tb_demo.frm 存储表定义；
2. tb_demo.MYD 存储数据；
3. tb_demo.MYI 存储索引。


**数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径.**


**MyISAM类型的表支持三种不同的存储结构：静态型、动态型、压缩型。**

静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。同时需要注意：*在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。*

动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。

压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。

**适用场景**
- 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。
- 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。

### InnoDB
 > InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。InnoDB引擎表是基于B+树的索引组织表(IOT)；每个表都需要有一个聚集索引(clustered index)；所有的行记录都存储在B+树的叶子节点(leaf pages of the tree)。

**自动增长列**
InnoDB表的自动增长列可以手工插入，但是插入的如果是空或0，则实际插入到则是自动增长后到值。可以通过`ALTER TABLE...AUTO_INCREMENT=n;`语句强制设置自动增长值的起始值，默认为1，但是该强制到默认值是保存在内存中，数据库重启后该值将会丢失。可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入多条记录，那么返回的是第一条记录使用的自动增长值。对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列

**外键约束**
MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，**包括restrict**、**cascade**、**set null**和**no action**。其中restrict和no action相同，是指限制在子表有关联的情况下，父表不能更新；casecade表示父表在更新或删除时，更新或者删除子表对应的记录；set null 则表示父表在更新或者删除的时候，子表对应的字段被set null。使用`set foreign_key_checks=0;`临时关闭外键约束，`set foreign_key_checks=1;`打开约束。

**适用场景**
- 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
- 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
- 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
- 外键约束。MySQL支持外键的存储引擎只有InnoDB。
- 支持自动增加列AUTO_INCREMENT属性。

**优化**

使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致，这时候存取效率是最高的

### MyISAM与InnoDB的区别
- 存储结构

  MyISAM:每个MyISAM在磁盘上存储成三个文件。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。
  InnoDB:所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
  
- 存储空间

  MyISAM:可被压缩，存储空间较小。支持三种不同的存储格式:静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
  InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
  
 - 可移植性、备份及恢复

	  MyISAM:数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。移植过程中MyISAM不受字典数据的影响。
	  InnoDB:免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。
  
 - 事务支持

	  MyISAM:强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
	  InnoDB:提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

- AUTO_INCREMENT

  MyISAM:可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
  InnoDB:InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
  
 - 表锁差异

	 MyISAM:只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。MYISAM对于count操作只需要在元数据中读取，不用扫表。
	  InnoDB:支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
  
  - 全文索引

	  MyISAM:支持 FULLTEXT类型的全文索引
	  InnoDB:不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
  
  - 表主键

	  MyISAM:允许没有任何索引和主键的表存在，索引都是保存行的地址。
	  InnoDB:如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
	  
- 表的具体行数

	 MyISAM:保存有表的总行数，如果`select count(*) from table;`会直接取出出该值。
	 InnoDB:没有保存表的总行数，如果使用`select count(*) from table;`就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 
	 
- CURD操作

  MyISAM:如果执行大量的SELECT，MyISAM是更好的选择。
  InnoDB:如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。

- 外键

	MyISAM:不支持
	InnoDB:支持




